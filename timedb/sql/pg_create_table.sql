BEGIN;

-- ============================================================================
-- 1) batches_table (formerly runs_table)
-- ----------------------------------------------------------------------------
-- Represents a "Batch" of data insertion.
-- This could be an automated workflow execution OR a manual API upload.
-- ============================================================================

CREATE TABLE IF NOT EXISTS batches_table (
  -- Unique identifier for the batch (generated by the API)
  batch_id           uuid PRIMARY KEY,

  -- Tenant identifier for multi-tenant support
  tenant_id          uuid NOT NULL,

  -- Identifier for the workflow/pipeline (Optional now)
  -- NULL for manual insertions
  workflow_id        text,

  -- Timing metadata (Optional now)
  -- If NULL, we assume the batch happens effectively "at insert time"
  batch_start_time   timestamptz,
  batch_finish_time  timestamptz,

  -- Time of knowledge: when the data was known/available
  -- Defaults to now()
  known_time         timestamptz NOT NULL DEFAULT now(),

  -- Parameters/config used for this batch (e.g. model version, API args)
  batch_params       jsonb,

  -- Audit timestamp
  inserted_at        timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT batch_params_is_object
    CHECK (batch_params IS NULL OR jsonb_typeof(batch_params) = 'object')
);

-- Index for querying history of a specific workflow
CREATE INDEX IF NOT EXISTS batches_workflow_start_idx
  ON batches_table (tenant_id, workflow_id, batch_start_time DESC);


-- ============================================================================
-- 2) series_table (Merged with Parameters)
-- ----------------------------------------------------------------------------
-- Defines WHAT is measured (name/unit) and WHERE/HOW (labels).
-- Removed parameters_table to simplify architecture.
-- ============================================================================

CREATE TABLE IF NOT EXISTS series_table (
  -- Unique identifier for the series
  series_id        uuid PRIMARY KEY,

  -- The "Parameter" definitions (formerly in parameters_table)
  -- e.g. 'wind_power', 'MW'
  name             text NOT NULL,
  unit             text NOT NULL,
  
  -- The differentiator (e.g. {"site": "Gotland", "turbine": "T01"})
  labels           jsonb NOT NULL DEFAULT '{}',
  
  description      text,
  inserted_at      timestamptz NOT NULL DEFAULT now(),

  -- Uniqueness: A series is defined by Name + Labels (unit is NOT part of uniqueness)
  -- This prevents creating multiple series with the same name+labels but different units
  CONSTRAINT series_identity_uniq UNIQUE (name, labels),

  -- Basic data hygiene
  CONSTRAINT series_name_not_empty CHECK (length(btrim(name)) > 0),
  CONSTRAINT series_unit_not_empty CHECK (length(btrim(unit)) > 0)
);

-- GIN index for efficient label-based filtering
-- Example: WHERE labels @> '{"site": "Gotland"}'
CREATE INDEX IF NOT EXISTS series_labels_gin_idx
  ON series_table USING GIN (labels);

-- B-Tree index for fast lookup by parameter name
-- Example: WHERE name = 'wind_speed'
CREATE INDEX IF NOT EXISTS series_name_idx
  ON series_table (name);


-- ============================================================================
-- 3) values_table (The versioned data points)
-- ----------------------------------------------------------------------------
-- Links to batch_id instead of run_id.
-- ============================================================================

CREATE TABLE IF NOT EXISTS values_table (
  value_id         bigserial PRIMARY KEY,

  -- Link to the Batch that inserted this value
  batch_id         uuid NOT NULL REFERENCES batches_table(batch_id) ON DELETE CASCADE,

  tenant_id        uuid NOT NULL,
  series_id        uuid NOT NULL REFERENCES series_table(series_id) ON DELETE CASCADE,

  valid_time       timestamptz NOT NULL,
  valid_time_end   timestamptz,

  value            double precision,

  -- Context/Audit columns
  annotation       text,
  metadata         jsonb,    -- Flexible metadata storage (e.g. {"quality": "good", "source": "manual"})
  tags             text[],   -- Use this for sparse metadata (e.g. ['interpolated'])
  changed_by       text,
  change_time      timestamptz NOT NULL DEFAULT now(),

  -- Versioning flag
  is_current       boolean NOT NULL DEFAULT true,

  -- Constraints
  CONSTRAINT valid_time_interval_check
    CHECK (valid_time_end IS NULL OR valid_time_end > valid_time),
  CONSTRAINT annotation_not_empty
    CHECK (annotation IS NULL OR length(btrim(annotation)) > 0),
  CONSTRAINT tags_not_empty_array
    CHECK (tags IS NULL OR cardinality(tags) > 0)
);

-- Uniqueness ensuring only one current value per tuple
-- Updated to include batch_id
CREATE UNIQUE INDEX IF NOT EXISTS values_one_current_idx
  ON values_table (
    batch_id,
    tenant_id,
    valid_time,
    COALESCE(valid_time_end, valid_time),
    series_id
  )
  WHERE is_current;

-- Indexes updated to reflect batch_id
CREATE INDEX IF NOT EXISTS values_batch_tenant_series_time_idx
  ON values_table (batch_id, tenant_id, series_id, valid_time, valid_time_end)
  WHERE is_current;

CREATE INDEX IF NOT EXISTS values_batch_time_idx
  ON values_table (batch_id, tenant_id, valid_time, valid_time_end);

-- Standard time/series indexes
CREATE INDEX IF NOT EXISTS values_valid_time_idx ON values_table (valid_time);
CREATE INDEX IF NOT EXISTS values_series_id_idx ON values_table (series_id);
CREATE INDEX IF NOT EXISTS values_tags_gin_idx ON values_table USING GIN (tags);
CREATE INDEX IF NOT EXISTS values_metadata_gin_idx ON values_table USING GIN (metadata);


-- ============================================================================
-- 5) Convenience Views
-- ============================================================================

CREATE OR REPLACE VIEW current_values_table AS
SELECT 
  v.*,
  s.name AS parameter_name,
  s.unit AS parameter_unit,
  s.labels AS series_labels
FROM values_table v
JOIN series_table s ON v.series_id = s.series_id
WHERE v.is_current = true;

COMMIT;