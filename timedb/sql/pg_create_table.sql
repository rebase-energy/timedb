BEGIN;

-- ============================================================================
-- 1) runs_table
-- ----------------------------------------------------------------------------
-- One row per workflow execution.
-- Stores metadata about the workflow run itself.
-- ============================================================================

CREATE TABLE IF NOT EXISTS runs_table (
  -- Unique identifier for the run (generated by the API)
  run_id           uuid PRIMARY KEY,

  -- Identifier for the workflow that produced this run
  workflow_id      text NOT NULL,

  -- When the workflow started and finished
  run_start_time   timestamptz NOT NULL,
  run_finish_time  timestamptz,

  -- Parameters/configuration used for this run
  -- e.g. model settings, API request params, feature flags
  run_params       jsonb,

  -- Automatically populated when the row is inserted
  inserted_at      timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT run_params_is_object
    CHECK (run_params IS NULL OR jsonb_typeof(run_params) = 'object')
);

-- Index to efficiently query runs for a given workflow, ordered by time
-- Typical query:
--   WHERE workflow_id = 'xyz'
--   ORDER BY run_start_time DESC
CREATE INDEX IF NOT EXISTS runs_workflow_start_idx
  ON runs_table (workflow_id, run_start_time DESC);


-- ============================================================================
-- 2) values_table
-- ----------------------------------------------------------------------------
-- Stores forecast values.
-- This table is VERSIONED:
--   - Updates create new rows
--   - Old rows are kept for audit/history
--   - Exactly one row is marked is_current = true per key
-- ============================================================================

CREATE TABLE IF NOT EXISTS values_table (
  -- Unique identifier for each version of a value
  value_id    bigserial PRIMARY KEY,

  -- Foreign key back to the run that produced these values
  run_id      uuid NOT NULL REFERENCES runs_table(run_id) ON DELETE CASCADE,

  -- Timestamp values are valid for
  valid_time  timestamptz NOT NULL,

  -- Optional end time for interval values
  -- NULL means the value is a point-in-time at valid_time
  valid_time_end timestamptz,

  -- What kind of series this is:
  -- e.g. 'mean', 'quantile:0.5', 'scenario:1'
  value_key   text NOT NULL,

  -- The workflow output value itself (can be NULL)
  -- NOTE: nullable so that NULL can be a valid stored value.
  -- In the application update API, we use _UNSET to mean "leave unchanged"
  -- and None/NULL to mean "explicitly set to NULL".
  value       double precision,

  -- Optional human annotations
  -- NULL means "no comment"
  -- Empty or whitespace-only strings are disallowed (see constraint below)
  comment     text,

  -- Optional tags
  -- NULL means "no tags"
  -- Empty arrays {} are disallowed (see constraint below)
  -- Tag normalization (trim/lower/dedupe/sort) is enforced in application code
  tags        text[],

  -- Audit metadata
  -- changed_by: user or service making the change
  -- change_time: automatically set when this version is created
  changed_by  text,
  change_time timestamptz NOT NULL DEFAULT now(),

  -- Exactly one row per (run_id, valid_time, valid_time_end, value_key) should be "current"
  is_current  boolean NOT NULL DEFAULT true,

  -- --------------------------------------------------------------------------
  -- Table-level constraints
  -- --------------------------------------------------------------------------

  -- If valid_time_end is provided, the value represents a time interval.
  -- Enforce that the interval has positive duration (end strictly after start).
  -- A NULL valid_time_end means the value is point-in-time at valid_time.
  CONSTRAINT valid_time_interval_check
    CHECK (
      valid_time_end IS NULL
      OR valid_time_end > valid_time
    ),

  -- We treat "" (or whitespace-only) comments as equivalent to NULL (no comment).
  -- Enforce that empty/whitespace-only strings cannot be stored.
  CONSTRAINT comment_not_empty
    CHECK (comment IS NULL OR length(btrim(comment)) > 0),

  -- We treat {} (empty array) tags as equivalent to NULL (no tags).
  -- Enforce that empty arrays cannot be stored; use NULL instead.
  CONSTRAINT tags_not_empty_array
    CHECK (tags IS NULL OR cardinality(tags) > 0)
);

-- ============================================================================
-- 3) Integrity & performance indexes
-- ============================================================================

-- Enforce that there is ONLY ONE current version per
-- (run_id, valid_time, valid_time_end, value_key)
-- This is the key guardrail that makes versioning safe.
CREATE UNIQUE INDEX IF NOT EXISTS values_one_current_idx
  ON values_table (
    run_id,
    valid_time,
    COALESCE(valid_time_end, valid_time),
    value_key
  )
  WHERE is_current;

-- Speeds up time-window queries across many runs
CREATE INDEX IF NOT EXISTS values_valid_time_idx
  ON values_table (valid_time);

-- Speeds up time-window queries for intervals
CREATE INDEX IF NOT EXISTS values_interval_idx
  ON values_table (
    valid_time,
    COALESCE(valid_time_end, valid_time)
  );

-- Speeds up fetching a full workflow run
CREATE INDEX IF NOT EXISTS values_run_time_idx
  ON values_table (run_id, valid_time, valid_time_end);

-- GIN index for efficient tag-based filtering
-- Example:
--   WHERE tags @> ARRAY['icing']
CREATE INDEX IF NOT EXISTS values_tags_gin_idx
  ON values_table USING GIN (tags);


-- ============================================================================
-- 4) Convenience view: current_values_table
-- ----------------------------------------------------------------------------
-- This view exposes ONLY the current values.
-- Most application queries should use this view instead of values_table
-- to avoid accidentally mixing in historical rows.
-- ============================================================================

CREATE OR REPLACE VIEW current_values_table AS
SELECT *
FROM values_table
WHERE is_current = true;

COMMIT;