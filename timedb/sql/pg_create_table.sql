BEGIN;

-- ============================================================================
-- 1) runs_table
-- ----------------------------------------------------------------------------
-- One row per workflow execution.
-- Stores metadata about the workflow run itself.
-- ============================================================================

CREATE TABLE IF NOT EXISTS runs_table (
  -- Unique identifier for the run (generated by the API)
  run_id           uuid PRIMARY KEY,

  -- Tenant identifier for multi-tenant support
  -- Single-tenant installs will use a fixed default tenant UUID
  tenant_id        uuid NOT NULL,

  -- Identifier for the workflow that produced this run
  workflow_id      text NOT NULL,

  -- When the workflow started and finished
  run_start_time   timestamptz NOT NULL,
  run_finish_time  timestamptz,

  -- Time of knowledge: when the data was known/available
  -- This can differ from run_start_time for backfill operations
  -- Defaults to inserted_at (now()) if not provided
  known_time       timestamptz NOT NULL DEFAULT now(),

  -- Parameters/configuration used for this run
  -- e.g. model settings, API request params, feature flags
  run_params       jsonb,

  -- Automatically populated when the row is inserted
  inserted_at      timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT run_params_is_object
    CHECK (run_params IS NULL OR jsonb_typeof(run_params) = 'object')
);

-- Index to efficiently query runs for a given tenant + workflow, ordered by time
-- Typical query:
--   WHERE tenant_id = '...' AND workflow_id = 'xyz'
--   ORDER BY run_start_time DESC
CREATE INDEX IF NOT EXISTS runs_workflow_start_idx
  ON runs_table (tenant_id, workflow_id, run_start_time DESC);


-- ============================================================================
-- 2) series_table
-- ----------------------------------------------------------------------------
-- Stores series metadata including the canonical unit for each series.
-- Each series has a unique series_id, a series_key (human-readable identifier),
-- and a series_unit (canonical unit like "MW", "kW", "MWh", "dimensionless").
-- ============================================================================

CREATE TABLE IF NOT EXISTS series_table (
  -- Unique identifier for the series
  series_id    uuid PRIMARY KEY,

  -- Human-readable identifier for the series
  -- e.g. 'wind_power_forecast', 'temperature_mean', 'energy_consumption'
  series_key   text NOT NULL,

  -- Optional description of the series
  -- e.g. 'Wind power forecast for the next 24 hours'
  description  text,

  -- Canonical unit for this series (Pint-compatible unit string)
  -- e.g. 'MW', 'kW', 'MWh', 'dimensionless', 'celsius'
  -- All values stored in values_table for this series are in this unit
  series_unit  text NOT NULL,

  -- Automatically populated when the row is inserted
  inserted_at  timestamptz NOT NULL DEFAULT now(),

  -- Ensure series_key is not empty
  CONSTRAINT series_key_not_empty
    CHECK (length(btrim(series_key)) > 0),

  -- Ensure series_unit is not empty
  CONSTRAINT series_unit_not_empty
    CHECK (length(btrim(series_unit)) > 0)
);

-- Index for efficient lookup by series_key
CREATE INDEX IF NOT EXISTS series_key_idx
  ON series_table (series_key);

-- Add description column if it doesn't exist (for existing databases)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'series_table' AND column_name = 'description'
  ) THEN
    ALTER TABLE series_table ADD COLUMN description text;
  END IF;
END $$;


-- ============================================================================
-- 3) values_table
-- ----------------------------------------------------------------------------
-- Stores forecast values.
-- This table is VERSIONED:
--   - Updates create new rows
--   - Old rows are kept for audit/history
--   - Exactly one row is marked is_current = true per key
-- ============================================================================

CREATE TABLE IF NOT EXISTS values_table (
  -- Unique identifier for each version of a value
  value_id    bigserial PRIMARY KEY,

  -- Foreign key back to the run that produced these values
  run_id      uuid NOT NULL REFERENCES runs_table(run_id) ON DELETE CASCADE,

  -- Tenant identifier for multi-tenant support
  -- Single-tenant installs will use a fixed default tenant UUID
  tenant_id   uuid NOT NULL,

  -- Timestamp values are valid for
  valid_time  timestamptz NOT NULL,

  -- Optional end time for interval values
  -- NULL means the value is a point-in-time at valid_time
  valid_time_end timestamptz,

  -- Foreign key to series_table
  -- References the series this value belongs to
  series_id   uuid NOT NULL REFERENCES series_table(series_id) ON DELETE CASCADE,

  -- The workflow output value itself (can be NULL)
  -- NOTE: This value is ALWAYS in the canonical unit specified in series_table.series_unit
  -- Unit conversion happens before insertion, so only the converted float is stored
  -- NOTE: nullable so that NULL can be a valid stored value.
  -- In the application update API, we use _UNSET to mean "leave unchanged"
  -- and None/NULL to mean "explicitly set to NULL".
  value       double precision,

  -- Optional human annotations
  -- NULL means "no annotation"
  -- Empty or whitespace-only strings are disallowed (see constraint below)
  annotation     text,

  -- Optional tags
  -- NULL means "no tags"
  -- Empty arrays {} are disallowed (see constraint below)
  -- Tag normalization (trim/lower/dedupe/sort) is enforced in application code
  tags        text[],

  -- Audit metadata
  -- changed_by: user or service making the change
  -- change_time: automatically set when this version is created
  changed_by  text,
  change_time timestamptz NOT NULL DEFAULT now(),

  -- Exactly one row per (run_id, tenant_id, valid_time, COALESCE(valid_time_end, valid_time), series_id) should be "current"
  is_current  boolean NOT NULL DEFAULT true,

  -- --------------------------------------------------------------------------
  -- Table-level constraints
  -- --------------------------------------------------------------------------

  -- If valid_time_end is provided, the value represents a time interval.
  -- Enforce that the interval has positive duration (end strictly after start).
  -- A NULL valid_time_end means the value is point-in-time at valid_time.
  CONSTRAINT valid_time_interval_check
    CHECK (
      valid_time_end IS NULL
      OR valid_time_end > valid_time
    ),

  -- We treat "" (or whitespace-only) annotations as equivalent to NULL (no annotation).
  -- Enforce that empty/whitespace-only strings cannot be stored.
  CONSTRAINT annotation_not_empty
    CHECK (annotation IS NULL OR length(btrim(annotation)) > 0),

  -- We treat {} (empty array) tags as equivalent to NULL (no tags).
  -- Enforce that empty arrays cannot be stored; use NULL instead.
  CONSTRAINT tags_not_empty_array
    CHECK (tags IS NULL OR cardinality(tags) > 0)
);

-- ============================================================================
-- 4) Integrity & performance indexes
-- ============================================================================

-- Enforce that there is ONLY ONE current version per
-- (run_id, tenant_id, valid_time, COALESCE(valid_time_end, valid_time), series_id)
-- This is the key guardrail that makes versioning safe.
-- Supports overlapping time series; run_id is the update identifier.
CREATE UNIQUE INDEX IF NOT EXISTS values_one_current_idx
  ON values_table (
    run_id,
    tenant_id,
    valid_time,
    COALESCE(valid_time_end, valid_time),
    series_id
  )
  WHERE is_current;

-- Speeds up time-window queries across many runs
CREATE INDEX IF NOT EXISTS values_valid_time_idx
  ON values_table (valid_time);

-- Speeds up time-window queries for intervals
CREATE INDEX IF NOT EXISTS values_interval_idx
  ON values_table (
    valid_time,
    COALESCE(valid_time_end, valid_time)
  );

-- Speeds up fetching current values for a given (run_id, tenant_id, series_id) over valid_time ranges
CREATE INDEX IF NOT EXISTS values_run_tenant_series_time_idx
  ON values_table (run_id, tenant_id, series_id, valid_time, valid_time_end)
  WHERE is_current;

-- Speeds up fetching all values for a run (run_id, tenant_id, valid_time, valid_time_end)
CREATE INDEX IF NOT EXISTS values_run_time_idx
  ON values_table (run_id, tenant_id, valid_time, valid_time_end);

-- Speeds up queries by series_id
CREATE INDEX IF NOT EXISTS values_series_id_idx
  ON values_table (series_id);

-- GIN index for efficient tag-based filtering
-- Example:
--   WHERE tags @> ARRAY['icing']
CREATE INDEX IF NOT EXISTS values_tags_gin_idx
  ON values_table USING GIN (tags);


-- ============================================================================
-- 5) Convenience view: current_values_table
-- ----------------------------------------------------------------------------
-- This view exposes ONLY the current values with series metadata joined.
-- Most application queries should use this view instead of values_table
-- to avoid accidentally mixing in historical rows.
-- ============================================================================

CREATE OR REPLACE VIEW current_values_table AS
SELECT 
  v.*,
  s.series_key,
  s.series_unit
FROM values_table v
JOIN series_table s ON v.series_id = s.series_id
WHERE v.is_current = true;

COMMIT;
